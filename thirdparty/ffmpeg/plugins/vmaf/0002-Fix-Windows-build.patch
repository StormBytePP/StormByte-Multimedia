From 5cc94f2817308a407d42f10f116d484b37bbf78e Mon Sep 17 00:00:00 2001
From: "David C. Manuelda" <StormByte@gmail.com>
Date: Fri, 2 Jan 2026 14:48:25 +0100
Subject: [PATCH] Fix Windows build

---
 libvmaf/src/compat/msvc/stdatomic.h |  2 --
 libvmaf/src/feature/integer_vif.c   | 36 +++++++++++++++--------------
 2 files changed, 19 insertions(+), 19 deletions(-)

diff --git a/libvmaf/src/compat/msvc/stdatomic.h b/libvmaf/src/compat/msvc/stdatomic.h
index 979ee2ba..7540775f 100644
--- a/libvmaf/src/compat/msvc/stdatomic.h
+++ b/libvmaf/src/compat/msvc/stdatomic.h
@@ -39,8 +39,6 @@
 
 #include <windows.h>
 
-#include "common/attributes.h"
-
 typedef volatile LONG  __declspec(align(32)) atomic_int;
 typedef volatile ULONG __declspec(align(32)) atomic_uint;
 
diff --git a/libvmaf/src/feature/integer_vif.c b/libvmaf/src/feature/integer_vif.c
index fd6a8231..3d98e384 100644
--- a/libvmaf/src/feature/integer_vif.c
+++ b/libvmaf/src/feature/integer_vif.c
@@ -630,23 +630,25 @@ static int init(VmafFeatureExtractor *fex, enum VmafPixelFormat pix_fmt,
     if (!data) return -ENOMEM;
     memset(data, 0, data_sz);
 
-    s->public.buf.data = data; data += pad_size;
-    s->public.buf.ref = data; data += frame_size + pad_size + pad_size;
-    s->public.buf.dis = data; data += frame_size + pad_size;
-    s->public.buf.mu1 = data; data += h * s->public.buf.stride_16;
-    s->public.buf.mu2 = data; data += h * s->public.buf.stride_16;
-    s->public.buf.mu1_32 = data; data += s->public.buf.stride_32;
-    s->public.buf.mu2_32 = data; data += s->public.buf.stride_32;
-    s->public.buf.ref_sq = data; data += s->public.buf.stride_32;
-    s->public.buf.dis_sq = data; data += s->public.buf.stride_32;
-    s->public.buf.ref_dis = data; data += s->public.buf.stride_32;
-    s->public.buf.tmp.mu1 = data; data += s->public.buf.stride_tmp;
-    s->public.buf.tmp.mu2 = data; data += s->public.buf.stride_tmp;
-    s->public.buf.tmp.ref = data; data += s->public.buf.stride_tmp;
-    s->public.buf.tmp.dis = data; data += s->public.buf.stride_tmp;
-    s->public.buf.tmp.ref_dis = data; data += s->public.buf.stride_tmp;
-    s->public.buf.tmp.ref_convol = data; data += s->public.buf.stride_tmp;
-    s->public.buf.tmp.dis_convol = data;
+    unsigned char *d = (unsigned char *)data;
+    s->public.buf.data = data;
+    d += pad_size;
+    s->public.buf.ref = d; d += frame_size + pad_size + pad_size;
+    s->public.buf.dis = d; d += frame_size + pad_size;
+    s->public.buf.mu1 = d; d += h * s->public.buf.stride_16;
+    s->public.buf.mu2 = d; d += h * s->public.buf.stride_16;
+    s->public.buf.mu1_32 = d; d += s->public.buf.stride_32;
+    s->public.buf.mu2_32 = d; d += s->public.buf.stride_32;
+    s->public.buf.ref_sq = d; d += s->public.buf.stride_32;
+    s->public.buf.dis_sq = d; d += s->public.buf.stride_32;
+    s->public.buf.ref_dis = d; d += s->public.buf.stride_32;
+    s->public.buf.tmp.mu1 = d; d += s->public.buf.stride_tmp;
+    s->public.buf.tmp.mu2 = d; d += s->public.buf.stride_tmp;
+    s->public.buf.tmp.ref = d; d += s->public.buf.stride_tmp;
+    s->public.buf.tmp.dis = d; d += s->public.buf.stride_tmp;
+    s->public.buf.tmp.ref_dis = d; d += s->public.buf.stride_tmp;
+    s->public.buf.tmp.ref_convol = d; d += s->public.buf.stride_tmp;
+    s->public.buf.tmp.dis_convol = d;
 
     s->feature_name_dict =
         vmaf_feature_name_dict_from_provided_features(fex->provided_features,
-- 
2.52.0

diff --git a/libvmaf/src/feature/ciede.c b/libvmaf/src/feature/ciede.c
index 7bbfa8f6..33a26fe1 100644
--- a/libvmaf/src/feature/ciede.c
+++ b/libvmaf/src/feature/ciede.c
@@ -52,6 +52,10 @@ SOFTWARE.
 #include "mem.h"
 #include "opt.h"
 
+#ifndef M_PI
+#define M_PI 3.14159265358979323846264338327
+#endif // M_PI
+
 typedef struct CiedeState {
     VmafPicture ref;
     VmafPicture dist;
diff --git a/libvmaf/src/read_json_model.c b/libvmaf/src/read_json_model.c
index 08405d3b..5a450257 100644
--- a/libvmaf/src/read_json_model.c
+++ b/libvmaf/src/read_json_model.c
@@ -493,15 +493,19 @@ static int model_collection_parse(json_stream *s, VmafModel **model,
     if (!c.name) return -ENOMEM;
 
     const size_t cfg_name_sz = strlen(name) + 5 + 1;
-    char cfg_name[cfg_name_sz];
+    char *cfg_name = malloc(cfg_name_sz);
+    if (!cfg_name) { free((char*)name); return -ENOMEM; }
 
     const size_t generated_key_sz = 4 + 1;
-    char generated_key[generated_key_sz];
+    char *generated_key = malloc(generated_key_sz);
+    if (!generated_key) { free(cfg_name); free((char*)name); return -ENOMEM; }
 
     unsigned i = 0;
     while (json_peek(s) != JSON_OBJECT_END && !json_get_error(s)) {
-        if (json_next(s) != JSON_STRING)
-            return -EINVAL;
+        if (json_next(s) != JSON_STRING) {
+            err = -EINVAL;
+            goto cleanup;
+        }
 
         const char *key = json_get_string(s, NULL);
         snprintf(generated_key, generated_key_sz, "%d", i);
@@ -509,14 +513,14 @@ static int model_collection_parse(json_stream *s, VmafModel **model,
         if (!strcmp(key, generated_key)) {
             VmafModel *m;
             err = vmaf_read_json_model(&m, &c, s);
-            if (err) return err;
+            if (err) { free(generated_key); free(cfg_name); free((char*)name); return err; }
 
             if (i == 0) {
                 *model = m;
                 c.name = cfg_name;
             } else {
                 err = vmaf_model_collection_append(model_collection, m);
-                if (err) return err;
+                if (err) { free(generated_key); free(cfg_name); free((char*)name); return err; }
             }
 
             sprintf((char*)c.name, "%s_%04d", name, ++i);
@@ -526,7 +530,10 @@ static int model_collection_parse(json_stream *s, VmafModel **model,
         json_skip(s);
     }
 
+cleanup:
     free((char*)name);
+    free(generated_key);
+    free(cfg_name);
     if (!(*model_collection)) return -EINVAL;
     return err;
 }
diff --git a/libvmaf/src/log.c b/libvmaf/src/log.c
index f93c7379..142e9c35 100644
--- a/libvmaf/src/log.c
+++ b/libvmaf/src/log.c
@@ -19,7 +19,13 @@
 #include "libvmaf/libvmaf.h"
 
 #include <stdarg.h>
-#include <unistd.h>
+#ifdef _WIN32
+# include <io.h>
+# define isatty _isatty
+# define fileno _fileno
+#else
+# include <unistd.h>
+#endif
 
 static enum VmafLogLevel vmaf_log_level = VMAF_LOG_LEVEL_INFO;
 static int istty = 0;
diff --git a/libvmaf/src/libvmaf.c b/libvmaf/src/libvmaf.c
index 18ccff0e..4f2d42ec 100644
--- a/libvmaf/src/libvmaf.c
+++ b/libvmaf/src/libvmaf.c
@@ -894,7 +894,8 @@ int vmaf_score_pooled_model_collection(VmafContext *vmaf,
     const char *suffix_stddev = "_stddev";
     const size_t name_sz =
         strlen(model_collection->name) + strlen(suffix_lo) + 1;
-    char name[name_sz];
+    char *name = malloc(name_sz);
+    if (!name) return -ENOMEM;
     memset(name, 0, name_sz);
 
     snprintf(name, name_sz, "%s%s", model_collection->name, suffix_bagging);
@@ -917,6 +918,7 @@ int vmaf_score_pooled_model_collection(VmafContext *vmaf,
                                      &score->bootstrap.ci.p95.hi,
                                      index_low, index_high);
 
+    free(name);
     return err;
 }
 
diff --git a/libvmaf/src/predict.c b/libvmaf/src/predict.c
index 9926de15..24e67985 100644
--- a/libvmaf/src/predict.c
+++ b/libvmaf/src/predict.c
@@ -358,7 +358,8 @@ static int vmaf_bootstrap_predict_score_at_index(
                                         VmafModelCollectionScore *score)
 {
     int err = 0;
-    double scores[model_collection->cnt];
+    double *scores = malloc(sizeof(double) * model_collection->cnt);
+    if (!scores) return -ENOMEM;
 
     for (unsigned i = 0; i < model_collection->cnt; i++) {
         // mean, stddev, etc. are calculated on untransformed/unclipped scores
@@ -370,7 +371,7 @@ static int vmaf_bootstrap_predict_score_at_index(
                                           feature_collector, index,
                                           &scores[i], false,
                                           false, flags);
-        if (err) return err;
+        if (err) { free(scores); return err; }
 
         // do not override the model's transform/clip behavior
         // write the scores to the feature collector
@@ -378,7 +379,7 @@ static int vmaf_bootstrap_predict_score_at_index(
         err = vmaf_predict_score_at_index(model_collection->model[i],
                                           feature_collector, index,
                                           &score, true, false, 0);
-        if (err) return err;
+        if (err) { free(scores); return err; }
     }
 
     score->type = VMAF_MODEL_COLLECTION_SCORE_BOOTSTRAP;
@@ -424,7 +425,8 @@ static int vmaf_bootstrap_predict_score_at_index(
     const char *suffix_stddev = "_stddev";
     const size_t name_sz =
         strlen(model_collection->name) + strlen(suffix_lo) + 1;
-    char name[name_sz];
+    char *name = malloc(name_sz);
+    if (!name) { free(scores); return -ENOMEM; }
     memset(name, 0, name_sz);
 
     snprintf(name, name_sz, "%s%s", model_collection->name, suffix_bagging);
@@ -443,6 +445,8 @@ static int vmaf_bootstrap_predict_score_at_index(
     err |= vmaf_feature_collector_append(feature_collector, name,
                                          score->bootstrap.ci.p95.hi,
                                          index);
+    free(name);
+    free(scores);
     return err;
 }
 
diff --git a/libvmaf/src/feature/mkdirp.h b/libvmaf/src/feature/mkdirp.h
index 02371fb5..e7776eba 100644
--- a/libvmaf/src/feature/mkdirp.h
+++ b/libvmaf/src/feature/mkdirp.h
@@ -12,6 +12,11 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
+#ifdef _MSC_VER
+/* On MSVC provide a minimal mode_t typedef */
+typedef int mode_t;
+#endif
+
 /*
  * Recursively `mkdir(path, mode)`
  */
diff --git a/libvmaf/src/feature/mkdirp.c b/libvmaf/src/feature/mkdirp.c
index 16fe966b..15c276f8 100644
--- a/libvmaf/src/feature/mkdirp.c
+++ b/libvmaf/src/feature/mkdirp.c
@@ -6,12 +6,21 @@
 // MIT licensed
 //
 
-#include <unistd.h>
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 #include "mkdirp.h"
 
+#ifdef _MSC_VER
+# include <io.h>
+# include <direct.h>
+# ifndef strdup
+#  define strdup _strdup
+# endif
+#else
+# include <unistd.h>
+#endif
+
 static char *
 path_normalize(const char *path) {
   if (!path) return NULL;
@@ -64,9 +73,9 @@ mkdirp(const char *path, mode_t mode) {
   free(parent);
 
   // make this one if parent has been made
-  #ifdef _WIN32
-    // http://msdn.microsoft.com/en-us/library/2fkk4dzw.aspx
-    int rc = mkdir(pathname);
+  #ifdef _MSC_VER
+    /* On MSVC use _mkdir which takes only a path. */
+    int rc = _mkdir(pathname);
   #else
     int rc = mkdir(pathname, mode);
   #endif
